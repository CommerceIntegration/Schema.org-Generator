#!/usr/bin/python3
"""
Bot for fetching the |Schema.org| |external_link| full hierarchy to generate the ``Hierarchy.pickle`` file

The Bot class will check for the existence of the pickle file and for the version

* If the file doesn't exist, it will be generated by the Bot

* If the file is outdated, it will be updated by the Bot

After updating the ``Hierarchy.pickle`` file, a new static ``index.html`` will be generated

The Bot should be called via a ``cron`` job every 24 hours

* The Application Server |Controller| (or Controllers) will be restarted if necessary
"""
# Refer to the Readme.txt file for Â© copyright information
from pickle import dump, load
from threading import Thread
from time import sleep
from urllib.error import URLError
from urllib.request import urlopen
from zlib import decompress, MAX_WBITS
from os import getcwd
from os.path import isdir
from subprocess import Popen
from model.schema import SchemaClass

HIERARCHY_FILE = 'Hierarchy.pickle'
READ_BINARY = 'rb'
WRITE_BINARY = 'wb'
MAX_SIMULTANEOUS_THREADS = 50


class Bot(Thread):
    def __init__(self):
        Thread.__init__(self)
        # Public attributes
        self.updated = False
        self.error = None
        self.version = 0.0     # Version of Schema.org

        # Private attributes
        self._is_alive = False
        self._schemas = {}      # Dictionary for rapid access

        self._generator_callback_busy = False   # Blocks callback
        self._threads = 1                       # Will be put at zero on first call, number of running threads
        self._i_thread = 0                      # Index of next thread to start
        self._i_max_thread = 0                  # Total number of threads to start

        self._schema_list = []                  # Ordered list, needed to generate the hierarchy correctly
        self._hierarchy = ['Thing', []]         # Hierarchy, list of lists for ordering output
        self._keys = None

    def run(self):
        is_dirty = False
        try:
            # First load the existing HIERARCHY_FILE
            with open(HIERARCHY_FILE, READ_BINARY) as f:
                pickle_list = load(f)
                self.version = pickle_list[0]
                self._schemas = pickle_list[1]
                self._hierarchy = pickle_list[2]
        except FileNotFoundError:
            # HIERARCHY_FILE is not there
            is_dirty = True
        is_dirty = True
        self.version = 0.0
        self._schemas = {}
        self._hierarchy = ['Thing', []]

        # Check the version of the Hierarchy against the known version
        i_tries = 0
        txt = None
        while i_tries < 9 and txt is None:
            i_tries += 1
            try:
                with urlopen("http://schema.org/docs/releases.html") as f:
                    txt = f.read()
                if 31 == txt[0]:  # If the txt is compressed, decompress
                    txt = decompress(txt, 16 + MAX_WBITS)
            except URLError:
                # Wait a millisecond before trying again
                print('Sleeping Schema_bot... waiting for version')
                sleep(0.1)

        if txt is None:
            # Abandon ship
            self.error = 'Schema bot abandoned. Check Internet connection'
            return

        # Check the version
        # <td class="release"><a href="/version/2.1/">2.1</a><br/>sdo-ganymede<br/>(2015-08-06)</td>
        txt = txt.decode()
        ind = txt.index('class="release"')
        ind += txt[ind:].index('href="')
        ind += txt[ind:].index('>') + 1
        version = float(txt[ind:ind + txt[ind:].index('<')])
        if version > self.version:
            self.version = version
            is_dirty = True

        if is_dirty:
            # If HIERARCHY_FILE is not there
            # Or there is a new version, get the hierarchy from the Internet
            self._start_refresh()

    def _start_refresh(self):
        """
        If there is a Hierarchy file, we can do this in the background
        If not, we have to do this immediately
        :return: None
        """
        self._is_alive = True

        # Backup and Remove files
        self._backup()

        try:
            # Get the full hierarchy from Schema.org
            with urlopen('http://schema.org/docs/full.html') as req:
                txt = req.read().decode("utf-8")

            self._refresh(txt)
        except URLError:
            self.error = 'Warning: http://schema.org/docs/full.html has not been found'
            self._is_alive = False

            # Restore files
            self._restore()

    def is_alive(self):
        return self._is_alive

    @staticmethod
    def _backup():
        """
        Moves all *.html files to another directory
        Moves HIERARCHY_FILE there as well
        """
        base_dir = '{0}'.format(getcwd())

        # Delete old directory (if it exists)
        if isdir('{0}/Schemas/old'.format(base_dir)):
            Popen(['rm -r {0}/Schemas/old'.format(base_dir)], shell=True)
            sleep(0.1)

        # Create old directory
        Popen(['mkdir {0}/Schemas/old'.format(base_dir)], shell=True)
        sleep(0.1)

        # Move all html files to the old directory
        Popen(['mv {0}/Schemas/*.html {0}/Schemas/old/'.format(base_dir)], shell=True)

        # Move HIERARCHY_FILE to the old directory
        Popen(['mv {0}/{1} {0}/Schemas/old/'.format(base_dir, HIERARCHY_FILE)], shell=True)

    @staticmethod
    def _restore():
        """
        Moves all *.html files back
        Moves HIERARCHY_FILE back
        """
        base_dir = '{0}'.format(getcwd())

        # Delete 'temporary' files
        Popen(['rm {0}/Schemas/*.html'.format(base_dir)], shell=True)
        Popen(['rm {0}/{1}'.format(base_dir, HIERARCHY_FILE)], shell=True)

        # Move all html files back
        Popen(['mv {0}/Schemas/old/*.html {0}/Schemas/'.format(base_dir)], shell=True)

        # Move HIERARCHY_FILE back
        Popen(['mv {0}/Schemas/old/{1} {0}/'.format(base_dir, HIERARCHY_FILE)], shell=True)

        # Delete old directory
        sleep(0.1)
        Popen(['rm -r {0}/Schemas/old'.format(base_dir)], shell=True)

    def _refresh(self, txt):
        # <li class="tbranch" id="Thing"><a href="/Thing">Thing</a>
        if 'class="tbranch" id="Thing"' not in txt:
            self.error = 'Error: class="tbranch" id="Thing" - Not found'
            return  # Incorrect - unlikely

        ind = txt.index('id="full_thing_tree"')              # Skip the core, go straight to the full_thing_tree
        ind += txt[ind:].index('class="tbranch" id="Thing"')   # We're looking for the first element
        # Get all elements
        # Read only 5 elements
        # index = 0
        thing = ''
        while True:
            # if index > 9:
            #     print('Exit after 10: {0}'.format(self._elements['IgnoreAction'].element))
            #     return
            # index += 1
            try:
                # <li class="tbranch" id="Thing"><a href="/Thing">Thing</a>
                ind += txt[ind:].index('id=')  # We want to extract the id
                ind += txt[ind:].index('"') + 1  # id="Thing"
                # Now, we have the id
                thing = txt[ind:ind + txt[ind:].index('"')]
                # if thing in ['Game', 'ExercisePlan', 'Diet']:
                #     pass  # Put a breakpoint here if needed
                if 'datatype_tree' == thing:
                    print('Correxit: datatype_tree')

                    # Launch the Threads
                    self._callback()
                    return
                # Check if Extended schema
                # <li class="tleaf" id="Motorcycle">
                #   <a title="Extended schema: auto.schema.org"  class="ext ext-auto"
                #       href="http://auto.schema.org/Motorcycle">Motorcycle</a>
                tmp = ind + txt[ind:].index('</a>')  # search between <a... and </a>
                if 'Extended' in txt[ind:tmp]:
                    # Get the url
                    ind += txt[ind:].index('href="')
                    ind += txt[ind:].index('"') + 1
                    # Now, we have the url
                    url = txt[ind:ind + txt[ind:].index('"')]
                    url = url[:url.rindex('/') + 1]
                    element = SchemaClass(thing, self._callback, url)
                else:
                    element = SchemaClass(thing, self._callback)
                self._schemas[thing] = element
                self._schema_list.append(thing)
            except Exception as e:
                self.error = 'Error: {0}\n'.format(e)
                self.error += 'Error exit: {0}'.format(thing)
                return  # Escape While True loop

    def _callback(self, element=None):
        # Only accept one callback at a time
        if self._generator_callback_busy:
            return False
        self._generator_callback_busy = True

        if element is None:
            # Initiate the keys and max threads
            print('start threads')
            self._keys = list(self._schemas.keys())
            self._i_max_thread = len(self._schemas)

        # One element has stopped, reduce the running threads
        self._threads -= 1

        # Start up to x simultaneous threads
        while self._threads < MAX_SIMULTANEOUS_THREADS and self._i_thread < self._i_max_thread:
            self._schemas[self._keys[self._i_thread]].start()
            self._i_thread += 1

            # May not be a thread, if not a thread, it's already finished
            if self._schemas[self._keys[self._i_thread - 1]].is_alive:
                self._threads += 1

        # All threads finished running
        if 0 == self._threads and self._i_thread == self._i_max_thread:
            # Ready
            self._dump()

        self._generator_callback_busy = False
        return True

    def _dump(self):
        # Create the hierarchy
        for thing in self._schema_list:
            schema = self._schemas[thing]
            parents = schema.get_parent_class

            if not parents:  # Thing has no parents
                continue

            # Every element has Thing at it's root, so it will be found
            # However, the parent we're looking for may be somewhere else, so keep looking
            hierarchy = self._hierarchy
            for x in range(0, len(parents)):
                for y in range(0, len(parents[x])):
                    try:
                        # Walk the hierarchy until the insertion point
                        hierarchy = hierarchy[hierarchy.index(parents[x][y]) + 1]
                    except ValueError:
                        # Reestablish the search tree
                        hierarchy = self._hierarchy
                        break
                # When the insertion point has been reached, exit the for loop
                if hierarchy != self._hierarchy:
                    break

            # Add the element to the hierarchy
            hierarchy.append(schema.name)
            hierarchy.append([])

        print('Finishing')
        self._is_alive = False
        self.updated = True

        # Reduce the amount of data saved by eliminating _html
        for schema in self._schemas.values():
            schema.clean()

        with open(HIERARCHY_FILE, WRITE_BINARY) as f:
            dump([self.version, self._schemas, self._hierarchy], f)

        # Delete old directory (if it exists)
        # sleep(0.1)
        base_dir = '{0}'.format(getcwd())
        if isdir('{0}/Schemas/old'.format(base_dir)):
            Popen(['rm -r {0}/Schemas/old'.format(base_dir)], shell=True)


def restart(port):
    try:
        urlopen('http://localhost:{0}/restart'.format(port))
    except URLError:
        pass

if __name__ == "__main__":
    from os import chdir
    # from datetime import datetime

    # tStart = datetime.now()

    print('Schema Bot - main')

    # Change the base dir to where this __file__ is located
    # Same location as the Hierarchy.pickle file
    FILE_NAME = 'schema_bot.py'
    if __file__ != FILE_NAME:
        BASE_DIR = __file__[:__file__.index(FILE_NAME)]
        chdir(BASE_DIR)

    # Start the Bot
    # Check if file exists
    # Check if version is correct
    b = Bot()
    b.start()
    b.join()

    # Everything happens while the bot is alive
    while b.is_alive():
        pass

    # Restart the server(s) if the pickle file has been updated
    if b.updated:
        restart(8000)   # Restart server at port 8000
        # restart(8001)   # Etc
    print('Schema Bot - main finished')

    # tFin = datetime.now()
    # tDiff = tFin - tStart
    # print("\nDuration:", ''.join([str(tDiff.seconds), ":", str(tDiff.microseconds)]))
